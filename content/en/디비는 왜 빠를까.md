---
date: 2018-09-25
description: Reading Masanobu Yoshinori's 'The Art of Supporting Databases'
image: /img/programming/files.jpg
keywords: database,데이터베이스,디비,인덱스,데이터베이스를 지탱하는 기술,해시인덱스,인댁스,
tags:
- '#데이터베이스'
- '#인덱스'
- '#해시인덱스'
- '#데이터저장'
- '#데이터관리'
templateKey: post
title: Why is the DB Fast?
---

Imagine you want to search for data with a user id of 1,234,567 in a large set of records. What's the fastest way to retrieve it?

* If you manage user information as 100 bytes each and store them sequentially, you could read 100 bytes starting from id x 100 byte. However, there's no guarantee that user information is fixed at 100 bytes, and you'd have to check if it exceeds 100 bytes upon writing due to this constraint. Furthermore, if many records don't use all 100 bytes, it would waste a lot of space. It's not practical in many ways.
* Have you ever seen an index page at the back of a book? It allows you to easily find desired pages just with keywords using the structure of (keyword, listed page). Similarly, what if you created a file recording the storage location of records on files for each user id? This is what we call an **index** structure.
* Such an index table consists of (key value, data location), allowing the use of fixed space. If you fix the index record at 8 bytes and store them by id order, you could read 123 * 8 bytes to access the location of id 123.
* Managing such an index table requires an additional step to access data, but it has the advantage of retrieving values with a cost that doesn't depend on the amount of data.
* Since the index is managed separately from the main data, you need to update the index separately when updating the main data.

Index entries consist only of (key value, data location), so it seems like using fixed space is possible. However, considering key values can be numbers, strings, dates/times, etc., guaranteeing fixed space becomes difficult. Therefore, real databases don't manage key values directly. Instead, they use a structure that pairs the values after applying them to a hash function. This is called a **hash index**.

* Hash calculations are generally O(1), so they're fast. Although there's an overhead of hash collisions as data grows, it's not a significant cost.
* However, such hash values are unsuitable for condition, range searches, and sorting.

  * Condition Search: Gifts priced below 10,000 won.
  * Range Search: List of games starting with 'Final'.
  * Sorting: Display products in ascending order of price.
* While they offer speed in reference and update, they don't solve all problems. They're just effective for specific use cases.

## B+ Tree Index

Is there an index that quickly returns results for condition, range searches, or sorting? The B+ Tree index structure aims to achieve that.

* B+ Tree is a tree structure. The top is called the root block, the bottom layer the leaf block, and the intermediate the branch block.

    ![btree](/img/programming/btree.jpg "btree")
* The root and branch blocks contain information about the location of the relevant block based on key values. The bottom leaf blocks contain storage location information. Thus, index lookup traverses from root → branch → leaf to retrieve the desired data.
* A B+ Tree is known as a multi-way tree due to having more than two branches from a block. The deeper the tree (number of levels), the more accesses occur. With binary trees, since you can't record more than 2^N at N levels, the depth increases, leading to more access counts.
* Multi-way trees like B+ Tree have a time complexity of O(logN), making them significantly faster compared to traversing all records, which is O(N), when there's a lot of data.
* B+ Tree can efficiently perform range searches like inequality or prefix matches without needing to go through branches; scanning leaf blocks completes these operations.
* B+ Tree index is the de facto standard in RDBMS. The explanation on why it's more suitable than other data structures like B-Tree is omitted.

## Index in RDBMS

* Guarantee of uniqueness: With hash indexes, you can easily check for duplicates with the same hash. In B+ Tree indexes, reaching the same leaf block enables easy duplicate checking with low cost.
* Multi-column index: It's possible to specify multiple columns as indexes, known as multi-column index. For instance, if you want to search for IDs under 100 and modification dates before September 30, 2009, multiple columns as indexes can speed up these AND condition searches. Consider how you could create a multi-column index. You can see the simple concept answer [here](https://stackoverflow.com/questions/36794891/how-mysql-multiple-column-index-works/36808673#36808673).
* Index merging: Suppose you want to find employees with department code 100 or hiring year 2010. With index merging, you perform set operations using AND and OR conditions on individual results, and then read data only on row numbers for efficient operations.

## Efforts to Reduce Update Costs

* Each time a record is added, the index must also be updated. In such cases, index updates will occur randomly across various index leaf blocks. This random access incurs high costs, making it critical to reduce these costs for performance. MySQL (InnoDB) temporarily records update information in memory or files and later updates the leaf at once.
* When adding/updating/deleting values in a B+ Tree index, you may need to relocate the index's leaf block. This is called leaf splitting. During this index reorganization process, reference/update operations are blocked. Thus, concurrency on addition/update/deletion isn't very high. MySQL (InnoDB) uses a partition table that internally manages multiple partitions to create a structure allowing parallel updates, thus increasing concurrency.

Using indexes isn't always beneficial. Sometimes you see indiscriminate index use, which can be considered irresponsible overengineering. Like all technologies, it's important to use them appropriately with a sense of balance. Without proper understanding, logical choices become impossible, and you'll resort to engineering by guesswork. 

Summary based on [The Art of Supporting Databases](http://www.yes24.com/24/goods/27893960).