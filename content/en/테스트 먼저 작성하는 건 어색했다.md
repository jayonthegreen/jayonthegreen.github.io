---
date: 2018-09-06
description: Reading Kent Beck's 'Test-Driven Development'
image: /img/book/TDD.jpeg
keywords: Kent Beck, Test-Driven Development, TDD
tags:
- '#TDD'
- '#TestDrivenDevelopment'
- '#CodeQuality'
- '#Refactoring'
- '#ProgrammingPractice'
templateKey: post
title: Writing Tests First Felt Awkward
---

At first, I thought writing automated tests meant practicing TDD (Test Driven Development). As I learned more, I assumed writing tests ‘first’ meant TDD. The word TDD lingered in my mind without any efforts to understand or practice it. I vaguely concluded that it would be good to write tests considering efficiency. However, as I explored the examples in this book, examined various principles, patterns, and values, I found it more interesting than I had anticipated.

By intentionally practicing the cycle of 'Writing a Test -> Failing -> Succeeding -> Refactoring,' I was surprised at how awkward it felt. By thinking from the perspective of how the code would be used, I wrote tests, implemented the minimal code necessary to pass the tests even if it was a fake implementation, and quickly went through cycles of refactoring. Through these repeated short feedback loops in implementation, I was able to write code more meticulously, considering various scenarios.

However, not all tests I wrote gave me this enjoyable feeling. There were times I endlessly mocked and wondered what exactly I was testing, and I even felt an extreme desire to rewrite the code. As I read this book with my colleagues and shared test cases with each other, we discussed our concerns about Mocking/Fixture and expressed the difficulty of writing tests for complex business logic while aiming for high cohesion and low coupling.

Did I get introduced to TDD through this book? I started to view TDD positively, from recognizing it as a practical way to improve code quality to seeing its practicality through running and verifying code. Of course, it is still true that I am inexperienced and lack experience, so writing tests is costly. Nevertheless, through this opportunity, I feel the need to practice TDD a bit more. I must engage in intentional practice.

cf) While looking at the Django tutorial, I read a section called [Why you need to create tests](https://docs.djangoproject.com/en/2.1/intro/tutorial05/#why-you-need-to-create-tests). I think it presents a clear logic.


## Summary
- On page 23, the sequence is determined as follows:
	- 1. Red - Write a small failing test. Initially, it might not even compile
	- 2. Green - Make it pass quickly. Any sin is permissible to achieve this.
	- 3. Refactoring - Remove all redundancy that emerged just to make the test pass.

- On page 43, when writing tests, imagining the perfect interface for operations is beneficial.
- On page 67, we do not strive for perfection. We only hope to reduce the degree of defects enough so that we can confidently move forward by saying everything twice (once in code, once in test).
- On page 85, we decided not to introduce more design before we have more motivators.
- On page 208, we must not take a step forward until the ground is secure. What are we trying to accomplish when we sit down to program?
- On page 210, the more stressed you are, the less likely it is that the testing will be sufficient. If you believe the tests were insufficient, the stress will increase. It's a positive feedback loop. Again, we need a way out of this loop. What about introducing the rule of writing tests first? Doing so could reverse the impact and create an effective cycle. 'Tests first' at the top is negatively connected to the stress below. Writing tests first decreases stress, thereby resulting in more tests being written. However, since there are other stress-inducing causes, the tests should also receive influence from other effective cycles.
- On page 210, after writing the code, we will not create tests. As a programmer, the goal is to make it executable. Meanwhile, it's also necessary to have time to think about the design of the program and ways to manage the scope of work.
- On page 244, implementing a fake is similar to using a piton to secure oneself during mountain climbing. Although you haven't reached there yet, you know it will be safe once you do.
- On page 297, I use method extraction when I want to understand complex code. "This part does something... what should I call it?"
- On page 318, what we definitely should not do is create tests for the entire code all at once, and refactor the entire code at once. Such tasks could take months, during which no new features would be added. Expenditure without income is generally not a sustainable process.
- On page 319, every programming method, whether explicit or implicit, contains certain value systems. TDD is no different. If you are happy to dump in a bunch of code just working to some degree and never look at it again, TDD is not for you. TDD rests on an appealingly naive and hacker-like assumption that you will be a tad more successful if you try to write better code. TDD helps you to adopt cleaner designs and to improve designs as you learn more, allowing you to focus on the appropriate problem at the right time.