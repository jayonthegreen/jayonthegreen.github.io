---
date: 2018-07-22
description: Reading Robert C. Martin's "Clean Code"
keywords: Clean Code, Development, Robert Martin
tags:
- '#Coding'
- '#Programming'
- '#Developer'
- '#CleanCode'
- '#Professionalism'
templateKey: post
title: Professionalism
---

<iframe src="https://coupa.ng/bhkoaZ" width="120" height="240" frameborder="0" scrolling="no"></iframe>

> Programmers who are content with merely functioning code lack professionalism. They may excuse themselves citing a lack of time to improve design and structure, but I disagree. Nothing affects a development project more negatively and for a longer time than bad code. A bad schedule can be redone. Bad requirements can be redefined. Bad team dynamics can be recovered. But bad code rots. It weighs down on a team, slowing them down until they crawl. I've seen teams burdened by malignant code due to a hurry, becoming a chain that rules their destiny forever. - From the book -

I've been a full-time programmer for over two years. I still feel there's much to learn. Reflecting on the past two years, it's clear that I was often in a rush. There are parts of the fast-paced implementation process that I'd like to commend myself for, such as practical considerations and improvements. However, looking back at the code I've written, I feel a lot of embarrassment. I know this emotion is healthy, but the embarrassment and guilt are hard to shake off. Regardless, I want to be judged by the results.

Looking back, I spent a considerable amount of time writing code by trial and error, with relatively little time spent contemplating the act of writing code itself. Writing a lot of code is important, but pondering over the fundamentals is necessary. Reading through the principles filled with the author's experiences and intuitions, I found myself in great agreement. Now that I've recharged my knowledge, it's time to take steps towards practice. The balance between technical debt and user value is an ever-present concern. Making one choice at a time for harmony is no easy task.

## Highlights

### chapter 1. Clean Code

- I've had experiences where I looked at junk code and thought I'd fix it later. That 'later' never comes.
- As bad code accumulates, team productivity declines and eventually approaches zero.
- Simple code passes all tests, has no duplication, expresses design ideas, and minimizes classes/methods/functions. - Ron Jeffries
- Reduce duplication, enhance expressiveness, and consider simple abstraction from the beginning.
- Leave the campsite cleaner than you found it. (...) Cleaning code does not require investing huge amounts of time and effort all at once. Improvement can be gradual.
- Reading books on art does not guarantee you become an artist.

### chapter 2. Meaningful Names

- Choose a word for an abstract concept and stick to it. For example, it's confusing to use different terms like fetch, retrieve, and get across classes for the same method.
- When the meaning is unclear, place it in a class/function/namespace to provide context. If all methods fail, prefixes are the last resort. (e.g., adding prefixes like addrFirstName, addrLastName, addrState to parameters, though it's better to create an Address class.)

### chapter 3. Functions

- Mixing levels of abstraction within a function confuses readers, making it hard to distinguish whether a phrase is a core concept or a detail. The problem doesn't end there. When you start mixing core concepts and details, it's like a broken window inviting people to add more details to the function.
- It's ideal for the abstraction part of the function to drop down one level at a time (the descending rule).
- Using descriptive names makes designs clearer in developers' minds.
- Even if you're returning input arguments directly, it's better to adhere to the format of a transformation function to maintain its form.
- Flag arguments are ugly.
- Do not cause side-effects.
- Separate command and query.
    ```java
    // bad
    if(set("username", "unclebob")) {
        ...
    }

    // good
    if(attributeExists("username")) {
        setAttribute("username", "unclebob");
    }
    ```
- Instead of declaring and using error codes, use exceptions. try/catch blocks are inherently ugly because they mix normal and error handling actions. Therefore, it's better to extract try/catch blocks into separate functions.
    ```java
    // bad
    if (deletePage(page) == E_OK) {
        if (registry.deleteReference(page.name) == E_OK) {
            if (configKeys.deleteKey(page.name.makeKey()) == E_OK) {
                logger.log("page deleted");
            } else {
                logger.log("configKey not deleted");
            }
        } else {
            logger.log("deleteReference from registry failed"); 
        }
    } else {
        logger.log("delete failed"); return E_ERROR;
    }
    ```

    ```java
    // good
    public void delete(Page page) {
        try {
            deletePageAndAllReferences(page);
        } catch (Exception e) {
            logError(e);
        }
    }

    private void deletePageAndAllReferences(Page page) throws Exception { 
        deletePage(page);
        registry.deleteReference(page.name); 
        configKeys.deleteKey(page.name.makeKey());
    }

    private void logError(Exception e) { 
        logger.log(e.getMessage());
    }
    ```

### chapter 4. Comments

- Express intent through code
    ```java
        // bad
        // Check if the employee is eligible for benefits
        if ((employee.flags & HOURLY_FLAG) && (employee.age > 65)) {
            ...
        }

        // good
        if (employee.isEligibleForFullBenefits()) {
            ...
        }
    ```
- It is foolish to apply rules that require Javadocs for every function or comments for every variable. Such comments clutter code, spread lies, and bring about confusion and disorder. Comments like the following add no value.
    ```java
    /**
    *
    * @param title CD title
    * @param author CD author
    * @param tracks CD track count
    * @param durationInMinutes CD length (in minutes)
    */
    public void addCD(String title, String author, int tracks, int durationInMinutes) {
        CD cd = new CD();
        cd.title = title;
        cd.author = author;
        cd.tracks = tracks;
        cd.duration = durationInMinutes;
        cdList.add(cd);
    }
    ```
- Do not comment if it can be expressed through a function or variable

    ```java
    // Does the global list <smodule> contain modules dependent on the subsystems we belong to?
    if (module.getDependSubsystems().contains(subSysMod.getSubSystem()))
    ```

    After removing the comment and rephrasing, it looks like this:

    ```java
    ArrayList moduleDependencies = smodule.getDependSubSystems();
    String ourSubSystem = subSysMod.getSubSystem();
    if (moduleDependees.contains(ourSubSystem))
    ```

### chapter 5. Formatting

- A good newspaper article has a headline (summary of the article), the first paragraph summarizes the contents, as you read down, more details and fine points emerge. 
The source file name (headline) should be simple yet descriptive, so that you can judge whether you're examining the right module just by its name. 
The top part of the source file (summary) describes the high-level concepts and algorithms. Going further down, you get more detailed descriptions, with the lowest-level functions (perhaps getters/setters?) and details appearing ultimately. Nobody would read a newspaper if it had one long article with scattered facts, dates, and names.
  
- Separate concepts with a blank line. Each line of code represents an expression or clause; several lines together express a complete thought. Separate thoughts with blank lines. Without this, code readability decreases significantly, even with the same number of line breaks.
  
- The closer code is placed together as conceptually close as possible. As seen earlier, dependencies such as when a function calls another, and when a variable and its using function are examples. Close conceptual affinity applies to groups of functions that perform similar actions as well.

### chapter 6. Objects and Data Structures

- What is hard to change in object-oriented code is easy in procedural code, and vice versa. (...) Wise programmers know that it's a myth to think that everything has to be an object. Sometimes simple data structures and procedural code are most suitable.
  
- The Law of Demeter is a well-known heuristic which says a module should not know the inner workings of the objects it manipulates.

### chapter 7. Error Handling

- Use exceptions instead of error codes
- Provide specific Exception types and reasons for exceptions.
- Wrapping exception codes can make them easier to manage in calling places.
```
  LocalPort port = new LocalPort(12);
  try {
    port.open();
  } catch (PortDeviceFailure e) {
    reportError(e);
    logger.log(e.getMessage(), e);
  } finally {
    ...
  }
  
  public class LocalPort {
    private ACMEPort innerPort;
    public LocalPort(int portNumber) {
      innerPort = new ACMEPort(portNumber);
    }
    
    // The calling site only has to handle PortDeviceFailure!
    public void open() {
      try {
        innerPort.open();
      } catch (DeviceResponseException e) {
        throw new PortDeviceFailure(e);
      } catch (ATM1212UnlockedException e) {
        throw new PortDeviceFailure(e);
      } catch (GMXError e) {
        throw new PortDeviceFailure(e);
      }
    }
    ...
  }
  ```
- Code that returns null not only increases workload but also passes the problem on to the caller.
- Do not pass null. Most programming languages do not provide adequate solutions for handling null passed as parameters.

### chapter 9. Unit Tests

- A few years ago, an author was asked to coach a team that had explicitly decided not to apply the same quality standards to test code as real code. Team members allowed each other to break rules for unit tests. "Dirty but quick" was the theme. Variable names didn't need care, test functions didn't need to be concise or expressive, test code didn't have to be well-designed, or separated with attention. It just needed to run and test the real code. However, the team did not realize that their dirty test code was as bad, if not worse than, not having tests. When the real code evolves, test code must change too. And the dirtier the test code, the harder it becomes to modify. Often, it takes more time to add a test case than to code the actual function. When the existing test cases begin failing because of changes in real code, it becomes increasingly hard to pass these failed tests with dirty code. Hence, the test code becomes a growing burden. (...)The effort poured into testing was certainly in vain. But the decision to allow sloppily written test code was the cause of failure.

- To write clean test code? Three keys are needed: readability, readability, readability.

- The BUILD-OPERATE-CHECK pattern suits such test structures. Each test is clearly divided into three sections. The first part sets up the test data. The second part manipulates test data, and the third part verifies if the manipulation results are correct.

- The standard applied to test API code is different from that applied to real code. It should be simple, concise, and expressive, but it doesn't need efficiency like real code because it runs in a test environment where the requirements differ.

- It is noteworthy above that the convention of renaming functions to given-when-then is used. It makes test code easier to read. Unfortunately, separating tests this way results in a lot of duplicate code. (...) TEMPLATE METHOD pattern can remove duplication. Place the given/when parts in the parent class and the then part in a child class.

- Perhaps the rule "test one concept per test function" is better. Avoid long functions that test various concepts consecutively.

### chapter 10. Classes

- Classes, first and foremost, should be small. Secondly, they should be small. Smaller still. Unlike functions measured in lines of code,
  
- The Single Responsibility Principle (SRP) states that a class or module should only have one reason to change. When you put effort into identifying the responsibilities, abstracting code becomes easier.
  
- If some functions use only certain instance variables, consider separating them into their class!
  
- Systems are inevitably subject to change. Each change risks disturbing the intended operation. A clean system systematically manages classes to minimize change-related risks. (...) Well-structured systems have minimal code to touch for additions and modifications.
  
- Client classes depending on concrete classes (details) are at risk when implementation changes.

### chapter 11. Systems

- A city cannot be built and managed by a single person. Yet the city functions. This is because it is modularized and maintained through modules like water, power, transport. Through a certain degree of abstraction, a city operates without needing an understanding of the whole picture. Software is composed similarly but often lacks the abstraction found in city modularization.

### chapter 12. Emergence

- Kent Beck states that if you follow these rules, the design is 'simple.'
    * Executes all tests.
    * Eliminates duplicates.
    * Expresses programmer intent.
    * Minimizes the number of classes and methods.

- Creating a clean system requires determination to eliminate even a few lines of duplication.

- Use standard nomenclature. For instance, design patterns primarily aim to enhance communication and expressiveness. If a class is implemented using a standard pattern such as COMMAND or VISITOR, include the pattern name in the class name to make the designer's intentions clear to other developers
  
- Pushing basic concepts like eliminating duplication, expressing intent, and adhering to SRP to the extreme can have more disadvantages than advantages. It's not uncommon to see cases where striving to reduce class and method sizes leads to countless small classes and methods. Hence, these rules suggest reducing functions and classes as much as possible.

### chapter 13. Concurrency

- Code that works in a single-thread environment is easy to write. Writing multi-threaded code that seems to work well is also easy.

- Myths and Misconceptions: Here are explanations of well-known myths and misconceptions.
    - Concurrency always improves performance. => Concurrency improves performance only when threads or processes can share wait times. And such cases are rare.
    - Writing concurrent programs does not change system design. => Separating "what" and "when" often significantly affects system structure.
    - Using containers like Web or EJB means there's no need to worry about concurrency issues. => Knowing what a container does and how to handle concurrent updates and deadlocks is necessary.

    - Bugs related to concurrency are often treated as one-off problems because they are hard to reproduce.

- One good way to solve shared resource problems is not to use shared resources in the first place. If they are used in read-only mode, using copies of the resource can be a solution. In some cases, delivering copies to multiple threads, performing operations, and collecting results in a single thread may be possible.

- Problems will occur suddenly. Those that don't are usually dismissed as "one-time" issues. These one-offs usually happen under system load or randomly. Therefore, repeatedly and continuously run thread-related code in various settings and environments.

### chapter 14. Incremental Improvement

- The lesson learned from decades of experience is that programming is more like craft than science. To write clean code, you must first write messy code and then clean it up.

- Once a program "runs," you move to the next task. A running program is abandoned regardless of its state. Experienced professional programmers understand that such behavior is professional suicide.

- TDD follows the principle that the system must always be running. In other words, TDD does not allow for destructive changes to the system.
  
- Programmers who are content with simply working code lack professionalism. They may cite a lack of time to improve design and structure, but I disagree. Bad code affects development projects more negatively and for longer periods than anything else. A bad plan can be redrawn. Poor requirements can be redefined. Bad team dynamics can be repaired. But bad code rots. It increases in weight, pulling the team down. Many teams slow down to a crawl. In their haste, they are bound in a malignant code that controls their destiny forevermore.

### chapter 17. Smells and Heuristics

A chapter listing principles based on the author's experience and intuition. While this list is not complete, it emphasizes value.

Heuristics: In contrast to algorithms, and when approached through dichotomy, refers to a thought process reflecting human "intuition." It's a "guesswork" method relying on experience and intuition rather than an exact procedure due to reasons like lack of time, information, cognitive resource constraints, and problem characteristics.